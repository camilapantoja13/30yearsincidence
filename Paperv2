# Loading the dataset and everything

install.packages("readxl")
library(readxl)
dataset_20250422 <- read_excel("/Users/mariacamilapantojaruiz/Library/Mobile Documents/com~apple~CloudDocs/Documents/PhD/Incidence 30 years/20250422 dataset.xlsx")
library(dplyr)      # For %>%
library(gt)         # For rendering the tables
library(readxl)
library(dplyr)
library(tidyr)
library(tidyverse)
install.packages("writexl")  
library(writexl)

# View first few rows
head(dataset_20250422)

# Then, set working directory for outputs
setwd("/Users/mariacamilapantojaruiz/Library/Mobile Documents/com~apple~CloudDocs/Documents/R")

# Ward codes (Just for me to read)
southwark95 <- c(
  "Cathedral", "Chaucer", "Bricklayers", "Riverside", 
  "Rotherhithe", Dockyard", "Browning", "Burgees", 
  "Newington", "Faraday", 
  "St Giles", Brunswick", 
)
southwark01 <- c(
  "Cathedrals", "Chaucer", "Grange", "Riverside", "Rotherhithe",
  "Surrey Docks", "Newington", "East Walworth", "South Bermondsey",
  "Faraday", "Camberwell Green"
)
southwark11 <- c(
  "Cathedrals", "Chaucer", "Grange", "Riverside", "Rotherhithe",
  "Surrey Docks", "Newington", "East Walworth", "South Bermondsey",
  "Faraday", "Camberwell Green"
)
southwark21 <- c(
  "Borough & Bankside", "Camberwell Green", "Chaucer", "Faraday",
  "London Bridge & West Bermondsey", "Newington (Southwark)", "North Bermondsey",
  "North Walworth", "Old Kent Road", "Rotherhithe",
  "South Bermondsey", "St George's (Southwark)", "Surrey Docks"
)
lambeth95 <- c("Bishop's", "Town Hall", "Streatham Hill", "Clapham Park", "Clapham Town", "Angell", "Herne Hill", "Ferndale",
               "Larkhall", "Oval", "Prince's", "Stockwell", "Thornton", "Tulse Hill", "Vassall")
lambeth01 <- c(
  "Bishop`s", "Brixton Hill", "Clapham Common", "Clapham Town", "Coldharbour", "Ferndale",
  "Herne Hill", "Larkhall", "Oval", "Prince`s", "Stockwell", "Thornton", "Tulse Hill", "Vassall"
)
lambeth11 <- c(
  "Bishop's", "Brixton Hill", "Clapham Common", "Clapham Town", "Coldharbour", "Ferndale",
  "Herne Hill", "Larkhall", "Oval", "Prince's", "Stockwell", "Thornton", "Tulse Hill", "Vassall"
)
lambeth21 <- c(
  "Waterloo & South Bank", "Vauxhall (Lambeth)", "Kennington (Lambeth)", "Oval",
  "Stockwell West & Larkhall", "Stockwell East", "Myatt's Fields", "Clapham Town",
  "Clapham East", "Clapham Common & Abbeville", "Brixton Acre Lane", "Brixton North",
  "Brixton Rush Common", "Clapham Park", "Brixton Windrush",
  "Herne Hill & Loughborough Junction", "St Martin's (Lambeth)"
)

# Valid LSOAs  (Just for me to read)
valid_lsoas_southwark <- c(
  # Cathedrals
  "E01003927", "E01003929", "E01003934", "E01003935", "E01003928",
  "E01003930", "E01003931", "E01003932", "E01003933",

  # Chaucer
  "E01003939", "E01003938", "E01003940", "E01003941", "E01003942",
  "E01003936", "E01003937", "E01003943", "E01003944",

  # Grange
  "E01003976", "E01003982", "E01003975", "E01003978", "E01003979",
  "E01003981", "E01003977", "E01003980",

  # Riverside
  "E01004025", "E01004026", "E01004027", "E01004022", "E01004023",
  "E01004028", "E01004024",

  # Rotherhithe
  "E01004029", "E01004032", "E01004030", "E01004031", "E01004033",
  "E01004034", "E01004036", "E01004035",

  # Surrey Docks
  "E01004053", "E01004054", "E01004055", "E01004056", "E01004057",
  "E01004058", "E01004059", "E01004060",

  # Newington
  "E01003994", "E01003992", "E01003995", "E01003996", "E01003998",
  "E01003999", "E01003991",

  # East Walworth
  "E01003959", "E01003960", "E01003961", "E01003962", "E01003965",
  "E01003964", "E01003966", "E01003963",

  # South Bermondsey
  "E01004037", "E01004038", "E01004042", "E01004043", "E01004039",
  "E01004040", "E01004041", "E01004044",

  # Faraday
  "E01003968", "E01003971", "E01003974", "E01003967", "E01003970",
  "E01003972", "E01003973", "E01003969",

  # Camberwell Green
  "E01003923", "E01003918", "E01003925", "E01003919", "E01003920",
  "E01003921", "E01003922", "E01003924", "E01003926"
)

valid_lsoas_lambeth <- c(
  # Bishop's
  "E01003012", "E01003013", "E01003014", "E01003016", "E01003017", "E01003015",

  # Brixton Hill
  "E01003019", "E01003020", "E01003018", "E01003021", "E01003022",
  "E01003023", "E01003024", "E01003025",

  # Clapham Common
  "E01003029", "E01003032", "E01003026", "E01003027", "E01003028",
  "E01003030", "E01003033", "E01003031",

  # Clapham Town
  "E01003034", "E01003035", "E01003036", "E01003037", "E01003038",
  "E01003039", "E01003040", "E01003042", "E01003041",

  # Coldharbour
  "E01003046", "E01003048", "E01003045", "E01003047", "E01003049",
  "E01003050", "E01003052", "E01003043", "E01003044", "E01003051",

  # Ferndale
  "E01003059", "E01003060", "E01003061", "E01003053", "E01003054",
  "E01003056", "E01003058", "E01003055", "E01003057",

  # Herne Hill
  "E01003075", "E01003072", "E01003073", "E01003076", "E01003077",
  "E01003078", "E01003071", "E01003074",

  # Larkhall
  "E01003089", "E01003091", "E01003092", "E01003088", "E01003093",
  "E01003094", "E01003096", "E01003090", "E01003095",

  # Oval
  "E01003101", "E01003102", "E01003103", "E01003104", "E01003098",
  "E01003099", "E01003100", "E01003097",

  # Prince's
  "E01003108", "E01003110", "E01003111", "E01003112", "E01003105",
  "E01003106", "E01003107", "E01003109",

  # Stockwell
  "E01003122", "E01003129", "E01003121", "E01003123", "E01003124",
  "E01003125", "E01003126", "E01003128", "E01003127",

  # Thornton
  "E01003159", "E01003160", "E01003162", "E01003156", "E01003157",
  "E01003158", "E01003161", "E01003163",

  # Tulse Hill
  "E01003176", "E01003171", "E01003173", "E01003177", "E01003178",
  "E01003172", "E01003174", "E01003175", "E01003179",

  # Vassall
  "E01003180", "E01003183", "E01003181", "E01003184", "E01003185",
  "E01003186", "E01003187", "E01003182", "E01003188"
)

# Actual code to put in R for creating the filter
valid_lsoas <- c(
  "E01003927", "E01003929", "E01003934", "E01003935", "E01003928", "E01003930", "E01003931", "E01003932", "E01003933",
  "E01003939", "E01003938", "E01003940", "E01003941", "E01003942", "E01003936", "E01003937", "E01003943", "E01003944",
  "E01003976", "E01003982", "E01003975", "E01003978", "E01003979", "E01003981", "E01003977", "E01003980",
  "E01004025", "E01004026", "E01004027", "E01004022", "E01004023", "E01004028", "E01004024",
  "E01004029", "E01004032", "E01004030", "E01004031", "E01004033", "E01004034", "E01004036", "E01004035",
  "E01004053", "E01004054", "E01004055", "E01004056", "E01004057", "E01004058", "E01004059", "E01004060",
  "E01003994", "E01003992", "E01003995", "E01003996", "E01003998", "E01003999", "E01003991",
  "E01003959", "E01003960", "E01003961", "E01003962", "E01003965", "E01003964", "E01003966", "E01003963",
  "E01004037", "E01004038", "E01004042", "E01004043", "E01004039", "E01004040", "E01004041", "E01004044",
  "E01003968", "E01003971", "E01003974", "E01003967", "E01003970", "E01003972", "E01003973", "E01003969",
  "E01003923", "E01003918", "E01003925", "E01003919", "E01003920", "E01003921", "E01003922", "E01003924", "E01003926",
  "E01003012", "E01003013", "E01003014", "E01003016", "E01003017", "E01003015",
  "E01003019", "E01003020", "E01003018", "E01003021", "E01003022", "E01003023", "E01003024", "E01003025",
  "E01003029", "E01003032", "E01003026", "E01003027", "E01003028", "E01003030", "E01003033", "E01003031",
  "E01003034", "E01003035", "E01003036", "E01003037", "E01003038", "E01003039", "E01003040", "E01003042", "E01003041",
  "E01003046", "E01003048", "E01003045", "E01003047", "E01003049", "E01003050", "E01003052", "E01003043", "E01003044", "E01003051",
  "E01003059", "E01003060", "E01003061", "E01003053", "E01003054", "E01003056", "E01003058", "E01003055", "E01003057",
  "E01003075", "E01003072", "E01003073", "E01003076", "E01003077", "E01003078", "E01003071", "E01003074",
  "E01003089", "E01003091", "E01003092", "E01003088", "E01003093", "E01003094", "E01003096", "E01003090", "E01003095",
  "E01003101", "E01003102", "E01003103", "E01003104", "E01003098", "E01003099", "E01003100", "E01003097",
  "E01003108", "E01003110", "E01003111", "E01003112", "E01003105", "E01003106", "E01003107", "E01003109",
  "E01003122", "E01003129", "E01003121", "E01003123", "E01003124", "E01003125", "E01003126", "E01003128", "E01003127",
  "E01003159", "E01003160", "E01003162", "E01003156", "E01003157", "E01003158", "E01003161", "E01003163",
  "E01003176", "E01003171", "E01003173", "E01003177", "E01003178", "E01003172", "E01003174", "E01003175", "E01003179",
  "E01003180", "E01003183", "E01003181", "E01003184", "E01003185", "E01003186", "E01003187", "E01003182", "E01003188"
)

# Filter dataset excluding <20y and unplausible years like >200 and exclusing if date is within STOP STROKE period *and* not in a valid LSOA 
slsr_clean <- dataset_20250422 %>%
  filter(!is.na(strk_d), !is.na(strk_m), !is.na(strk_y)) %>%
  mutate(
    dtstrk = as.Date(paste(strk_y, strk_m, strk_d, sep = "-"), format = "%Y-%m-%d"),
    year = year(dtstrk)
  ) %>%
  filter(
    !is.na(sex),
    !is.na(age),
    age >= 20 & age <= 200,  
    !(dtstrk >= as.Date("2004-11-15") & dtstrk <= as.Date("2007-12-31") &
      !(lsoa11 %in% valid_lsoas))
  )

# Identify stroke_type in ischaemic, PICH and SAH
slsr_clean <- slsr_clean %>%
  mutate(
    stroke_type = case_when(
      # Primary: OCSP classification
      subtype %in% 1:5 ~ "Ischaemic",
      subtype == 6 ~ "PICH",
      subtype == 7 ~ "SAH",

      # Fallback 1: stroke subtype
      is.na(subtype) & strksub == 1 ~ "Ischaemic",
      is.na(subtype) & strksub == 2 ~ "PICH",
      is.na(subtype) & strksub == 3 ~ "SAH",

      # Fallback 2: infarct/haemorrhage
      is.na(subtype) & is.na(strksub) & stroke == 1 ~ "Ischaemic",

      # Still unknown
      TRUE ~ "Unknown"
    )
  )

# Extract ethnicity from your cleaned dataset
slsr_clean <- slsr_clean %>%
  mutate(
    ethnicity = case_when(
      eth6cat == 1 ~ "White",
      eth6cat == 2 ~ "Black Caribbean",
      eth6cat == 3 ~ "Black African",
      eth6cat == 4 ~ "Black Other",
      eth6cat == 5 ~ "Other",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(ethnicity))

## Fixing the "Others" problem
#Counting
slsr_clean %>%
    filter(strk_y >= 1995, strk_y <= 1995, eth6cat == 5) %>%
    summarise(n_other = n())

ids_others_1995_old <- slsr_clean %>%
  filter(strk_y == 1995, eth6cat == 5) %>%
  pull(id)
ids_others_1995_new <- SES_inequality_Dec_24 %>%
  filter(strk_y == 1995, eth6cat == 5) %>%
  pull(id)

# Find mismatches (those in old dataset but not in new "Others")
mismatched_ids <- setdiff(ids_others_1995_old, ids_others_1995_new)

# Check their new eth6cat values in SES_inequality_Dec_24
SES_inequality_Dec_24 %>%
  filter(id %in% mismatched_ids) %>%
  count(eth6cat)

library(dplyr)

# Step 1: Create a lookup table with id and the corrected eth6cat
eth6cat_lookup <- SES_inequality_Dec_24 %>%
  select(id, corrected_eth6cat = eth6cat)

# Step 2: Join the corrected values into slsr_clean and replace eth6cat
slsr_clean <- slsr_clean %>%
  left_join(eth6cat_lookup, by = "id") %>%
  mutate(
    eth6cat = if_else(!is.na(corrected_eth6cat), corrected_eth6cat, eth6cat)
  ) %>%
  select(-corrected_eth6cat)  # Remove the temporary column


# ------------------------------------------------------------------
# Table 1
# ------------------------------------------------------------------

library(dplyr)
library(tidyr)

# Identify stroke types
slsr_clean <- slsr_clean %>%
  mutate(
    stroke_class = case_when(
      stroke == 1 | strksub == 1 | subtype %in% 1:5 ~ "Ischaemic",
      strksub == 2 | subtype == 6 ~ "PICH",
      strksub == 3 | subtype == 7 ~ "SAH",
      strksub == 4 | subtype %in% 8:9 ~ "Unknown",
      TRUE ~ "Unclassified"  # fallback if none match
    )
  )

# Identify ethnicity
slsr_clean <- slsr_clean %>%
  mutate(
    ethnicity = case_when(
      eth6cat == 1 ~ "White",
      eth6cat == 2 ~ "Black Caribbean",
      eth6cat == 3 ~ "Black African",
      eth6cat == 4 ~ "Black Other",
      eth6cat == 5 ~ "Other",
      eth6cat == 99 ~ "Unknown",
      TRUE ~ NA_character_  # if eth6cat is NA or unexpected
    )
  )
# Checking it makes sense
slsr_clean %>%
  count(ethnicity, stroke_class) %>%
  arrange(ethnicity, desc(n))

# Creating period variable
slsr_clean <- slsr_clean %>%
  mutate(
    period = case_when(
      strk_y >= 1995 & strk_y <= 1999 ~ "1995-1999",
      strk_y >= 2000 & strk_y <= 2004 ~ "2000-2004",
      strk_y >= 2005 & strk_y <= 2009 ~ "2005-2009",
      strk_y >= 2010 & strk_y <= 2014 ~ "2010-2014",
      strk_y >= 2015 & strk_y <= 2019 ~ "2015-2019",
      strk_y >= 2020 & strk_y <= 2024 ~ "2020-2024",
      TRUE ~ "Outside range"
    )
  )

# Create summary table
summary_table <- slsr_clean %>%
  filter(period != "Outside range") %>%
  count(period, ethnicity, stroke_class) %>%
  arrange(period, ethnicity, stroke_class)

# == Formatting for table 1 ==
library(dplyr)
library(dplyr)
library(tidyr)
library(writexl)

# Step 1: Filter just the main stroke classes
stroke_summary <- slsr_clean %>%
  filter(stroke_class %in% c("Ischaemic", "PICH", "SAH"))

# Step 2: Create ethnicity-specific group labels
ethnicity_counts <- stroke_summary %>%
  mutate(group = ethnicity) %>%
  count(group, stroke_class, period)

# Step 3: Create the "Overall" totals
overall_counts <- stroke_summary %>%
  count(group = "Overall", stroke_class, period)

# Step 4: Combine both sets
combined_counts <- bind_rows(overall_counts, ethnicity_counts)

# Step 5: Create a label for each row (e.g. "White - Ischaemic")
combined_counts <- combined_counts %>%
  mutate(row_label = paste(group, stroke_class, sep = " - "))

# Step 6: Pivot to wide format
final_table <- combined_counts %>%
  select(row_label, period, n) %>%
  pivot_wider(names_from = period, values_from = n, values_fill = 0)

# Step 7: Save to Excel
write_xlsx(final_table, "stroke_summary_all_ethnicities.xlsx")

# == Calculating the person-years == 
population <- read.csv("population_by_ethnicity.csv")
head(population)

population <- population_by_ethnicity
# Add years

library(dplyr)

population_filtered <- population %>%
  filter(Year >= 1995 & Year <= 2024) %>%  # only keep years within analysis range
  mutate(
    period = case_when(
      Year %in% 1995:1999 ~ "1995-1999",
      Year %in% 2000:2004 ~ "2000-2004",
      Year %in% 2005:2009 ~ "2005-2009",
      Year %in% 2010:2014 ~ "2010-2014",
      Year %in% 2015:2019 ~ "2015-2019",
      Year %in% 2020:2024 ~ "2020-2024",
      TRUE ~ NA_character_
    )
  )
# summarising
population_years <- population_filtered %>%
  group_by(Ethnicity, period) %>%
  summarise(
    n = sum(Total, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    stroke_class = "Population-years",
    group = Ethnicity,
    row_label = paste(group, stroke_class, sep = " - ")
  )
library(tidyr)

pop_table <- population_years %>%
  select(row_label, period, n) %>%
  pivot_wider(names_from = period, values_from = n, values_fill = 0)

final_table_with_pop <- bind_rows(final_table, pop_table)

# Add overall
overall_pop <- population_years %>%
  group_by(period) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    group = "Overall",
    stroke_class = "Population-years",
    row_label = paste(group, stroke_class, sep = " - ")
  )
population_years_all <- bind_rows(population_years, overall_pop)
pop_table <- population_years_all %>%
  select(row_label, period, n) %>%
  pivot_wider(names_from = period, values_from = n, values_fill = 0)

final_table_with_pop <- bind_rows(final_table, pop_table)

# Optional: Save to Excel
write_xlsx(final_table_with_pop, "stroke_summary_with_population_years.xlsx")

# ------------------------------------------------------------------
# Table 2
# ------------------------------------------------------------------

# Load population
population_age_ethnicity <- read_csv(
  "/Users/mariacamilapantojaruiz/Library/Mobile Documents/com~apple~CloudDocs/Documents/PhD/Incidence 30 years/Census check/Checked/Interpolation/population_by_age_ethnicity_sex.csv"
) %>%
  group_by(year = Year, ethnicity = Ethnicity, age_group = `Age Range`) %>%
  summarise(population = sum(Total, na.rm = TRUE), .groups = "drop") %>%
  filter(year >= 1995, year <= 2024)

# Load ESP weights
library(tibble)
esp <- tibble::tibble(
  age_group = c(
    "20-24", "25-29", "30-34", "35-39", "40-44", "45-49",
    "50-54", "55-59", "60-64", "65-69", "70-74", "75-79",
    "80-84", "85+"
  ),
  std_pop = c(
    6000, 6000, 6500, 7000, 7000, 7000,
    7000, 6500, 6000, 5500, 5000, 4000,
    2500, 1500 + 1000  # 85–89 + 90+
  )
)

library(dplyr)

# prepare population by time period
population_period_age_ethnicity <- population_age_ethnicity %>%
  mutate(period = case_when(
    year %in% 1995:1999 ~ "1995-1999",
    year %in% 2000:2004 ~ "2000-2004",
    year %in% 2005:2009 ~ "2005-2009",
    year %in% 2010:2014 ~ "2010-2014",
    year %in% 2015:2019 ~ "2015-2019",
    year %in% 2020:2024 ~ "2020-2024",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(period)) %>%
  group_by(period, ethnicity, age_group) %>%
  summarise(population = sum(population), .groups = "drop")

# Add ESP- compatible age_group
slsr_clean <- slsr_clean %>%
  mutate(
    age_group = case_when(
      age >= 20 & age <= 24 ~ "20-24",
      age >= 25 & age <= 29 ~ "25-29",
      age >= 30 & age <= 34 ~ "30-34",
      age >= 35 & age <= 39 ~ "35-39",
      age >= 40 & age <= 44 ~ "40-44",
      age >= 45 & age <= 49 ~ "45-49",
      age >= 50 & age <= 54 ~ "50-54",
      age >= 55 & age <= 59 ~ "55-59",
      age >= 60 & age <= 64 ~ "60-64",
      age >= 65 & age <= 69 ~ "65-69",
      age >= 70 & age <= 74 ~ "70-74",
      age >= 75 & age <= 79 ~ "75-79",
      age >= 80 & age <= 84 ~ "80-84",
      age >= 85 ~ "85+",
      TRUE ~ NA_character_
    )
  )

# ESP counts
library(tibble)

esp <- tibble(
  age_group = c(
    "20-24", "25-29", "30-34", "35-39", "40-44", "45-49",
    "50-54", "55-59", "60-64", "65-69", "70-74", "75-79",
    "80-84", "85+"
  ),
  std_pop = c(
    6000, 6000, 6500, 7000, 7000, 7000,
    7000, 6500, 6000, 5500, 5000, 4000,
    2500, 2500  # 85–89 (1500) + 90+ (1000)
  )
)

# Count strokes
stroke_cases_age <- slsr_clean %>%
  filter(stroke_class %in% c("Ischaemic", "PICH", "SAH")) %>%
  filter(!is.na(age_group)) %>%
  group_by(period, ethnicity, age_group, stroke_class) %>%
  summarise(n = n(), .groups = "drop")


# Calculate ESP R Spiegelman-based function
calc_asir_ci <- function(df, esp_table) {
  df %>%
    left_join(esp_table, by = "age_group") %>%
    mutate(
      rate = (n / population) * 100000,
      weight_prop = std_pop / sum(std_pop, na.rm = TRUE),
      weighted_rate = rate * weight_prop,
      var_component = ((rate / population) * (weight_prop ^ 2))
    ) %>%
    summarise(
      period = unique(period),
      ethnicity = unique(ethnicity),
      stroke_class = unique(stroke_class),
      asir = sum(weighted_rate, na.rm = TRUE),
      se = sqrt(sum(var_component, na.rm = TRUE)),
      lower_ci = asir - 1.96 * se,
      upper_ci = asir + 1.96 * se,
      .groups = "drop"
    ) %>%
    mutate(
      lower_ci = pmax(0, round(lower_ci, 1)),
      upper_ci = round(upper_ci, 1),
      asir = round(asir, 1)
    )
}

esp_asir_summary <- stroke_cases_age %>%
  left_join(population_period_age_ethnicity, by = c("period", "ethnicity", "age_group")) %>%
  group_by(period, ethnicity, stroke_class) %>%
  group_split() %>%
  purrr::map_dfr(~ calc_asir_ci(.x, esp))

# Formatting
esp_asir_summary <- esp_asir_summary %>%
  mutate(
    label = paste0(asir, " (", lower_ci, "–", upper_ci, ")")
  )

library(tidyr)

esp_asir_table <- esp_asir_summary %>%
  select(period, ethnicity, stroke_class, label) %>%
  pivot_wider(names_from = period, values_from = label, values_fill = "")

library(writexl)
write_xlsx(esp_asir_table, "esp_asir_summary_publication.xlsx")

library(officer)
library(flextable)

doc <- read_docx()
ft <- flextable(esp_asir_table)
ft <- autofit(ft)
doc <- body_add_flextable(doc, ft)
print(doc, target = "esp_asir_summary_publication.docx")

# Just realised im missing the overall
# Recalculate the population across all ethnicities
stroke_cases_overall <- stroke_cases_all %>%
  group_by(period, age_group, stroke_class) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop") %>%
  mutate(ethnicity = "Overall")

# add this to stroke_cases_all
stroke_cases_all <- bind_rows(stroke_cases_all, stroke_cases_overall)

# Create "Overall" group in the population table
overall_population <- population_period_age_ethnicity %>%
  group_by(period, age_group) %>%
  summarise(population = sum(population, na.rm = TRUE), .groups = "drop") %>%
  mutate(ethnicity = "Overall")

# Append to the existing population table
population_period_age_ethnicity <- bind_rows(
  population_period_age_ethnicity,
  overall_population
)

# Ensure every age group is present
all_groups <- expand.grid(
  period = unique(stroke_cases_all$period),
  ethnicity = unique(stroke_cases_all$ethnicity),
  age_group = unique(population_period_age_ethnicity$age_group),
  stroke_class = c("Ischaemic", "PICH", "SAH", "Total strokes")
)

# Fill missing n with 0
stroke_cases_all <- all_groups %>%
  left_join(stroke_cases_all, by = c("period", "ethnicity", "age_group", "stroke_class")) %>%
  mutate(n = replace_na(n, 0))

# Calculate
esp_asir_summary <- stroke_cases_all %>%
  left_join(population_period_age_ethnicity, by = c("period", "ethnicity", "age_group")) %>%
  group_by(period, ethnicity, stroke_class) %>%
  group_split() %>%
  purrr::map_dfr(~ calc_asir_ci(.x, esp))

#Checking
library(dplyr)
library(tidyr)

esp_check <- esp_asir_summary %>%
  filter(stroke_class %in% c("Ischaemic", "PICH", "SAH", "Total strokes")) %>%
  select(period, ethnicity, stroke_class, asir) %>%
  pivot_wider(names_from = stroke_class, values_from = asir) %>%
  mutate(
    max_subtype = pmax(Ischaemic, PICH, SAH, na.rm = TRUE),
    issue = `Total strokes` < max_subtype
  ) %>%
  filter(issue == TRUE)

# Formatting the table
library(tidyr)
library(dplyr)

# Make sure Overall is first
esp_asir_table <- esp_asir_summary %>%
  mutate(
    ethnicity = factor(
      ethnicity,
      levels = c("Overall", sort(unique(ethnicity[ethnicity != "Overall"])))
    ),
    label = paste0(asir, " (", lower_ci, "–", upper_ci, ")")
  ) %>%
  select(ethnicity, stroke_class, period, label) %>%
  pivot_wider(
    names_from = period,
    values_from = label,
    values_fill = ""
  ) %>%
  arrange(ethnicity, stroke_class)

library(writexl)

# Save to Excel
write_xlsx(esp_asir_table, "ESP_ASIR_Table.xlsx")

# ------------------------------------------------------------------
# Supplementary 1
# ------------------------------------------------------------------

library(dplyr)
library(broom)
library(purrr)

library(dplyr)
library(purrr)
library(broom)

# Define ordered periods
period_levels <- c("1995-1999", "2000-2004", "2005-2009",
                   "2010-2014", "2015-2019", "2020-2024")

# Aggregate stroke data
poisson_data <- stroke_cases_all %>%
  left_join(population_period_age_ethnicity,
            by = c("period", "ethnicity", "age_group")) %>%
  group_by(period, ethnicity, stroke_class) %>%
  summarise(
    cases = sum(n, na.rm = TRUE),
    person_years = sum(population, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(period = factor(period, levels = period_levels, ordered = TRUE))

# Create pairwise comparisons
period_pairs <- tibble(
  ref = period_levels[-length(period_levels)],
  comp = period_levels[-1]
)

# Model function
run_safe_model <- function(df_group, ref, comp) {
  df_sub <- df_group %>% filter(period %in% c(ref, comp))
  
  if (nrow(df_sub) < 2 || sum(df_sub$cases) == 0) return(NULL)
  
  df_sub <- df_sub %>%
    mutate(period = factor(period, levels = c(ref, comp)))
  
  tryCatch({
    model <- glm(cases ~ period, offset = log(person_years),
                 family = poisson(link = "log"), data = df_sub)
    
    tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(
        comparison = paste0(comp, " vs ", ref),
        IRR = estimate,
        lower_CI = conf.low,
        upper_CI = conf.high,
        change = case_when(
          p.value < 0.05 & IRR > 1 ~ "↑",
          p.value < 0.05 & IRR < 1 ~ "↓",
          TRUE ~ "↔"
        )
      ) %>%
      select(IRR, lower_CI, upper_CI, p.value, comparison, change)
    
  }, error = function(e) NULL)
}

# Run comparisons for each group
poisson_results <- poisson_data %>%
  group_by(ethnicity, stroke_class) %>%
  group_split() %>%
  map_dfr(function(df_group) {
    map_dfr(1:nrow(period_pairs), function(i) {
      res <- run_safe_model(df_group, period_pairs$ref[i], period_pairs$comp[i])
      if (!is.null(res)) {
        res$ethnicity <- unique(df_group$ethnicity)
        res$stroke_class <- unique(df_group$stroke_class)
      }
      res
    })
  }) %>%
  relocate(ethnicity, stroke_class, comparison)

# Format and save
# Load necessary libraries
library(dplyr)
library(flextable)
library(officer)
library(writexl)

# Format p-values and create IRR label
library(dplyr)
library(flextable)
library(officer)
library(writexl)

# Format and label IRR with 95% CI and formatted p-values
poisson_results_formatted <- poisson_results %>%
  mutate(
    p.value_fmt = case_when(
      p.value < 0.001 ~ "<0.001",
      TRUE ~ formatC(p.value, format = "f", digits = 3)
    ),
    IRR_label = paste0(
      round(IRR, 2), " (", 
      round(lower_CI, 2), "–", 
      round(upper_CI, 2), "), p=", 
      p.value_fmt
    )
  ) %>%
  select(ethnicity, stroke_class, comparison, IRR_label, change)

# Save to Excel
write_xlsx(poisson_results_formatted, "poisson_results_formatted.xlsx")

# Save to Word
doc <- read_docx()
ft <- flextable(poisson_results_formatted) %>%
  autofit()
doc <- body_add_flextable(doc, ft)
print(doc, target = "poisson_results_formatted.docx")

# Splitting them into different tables and adding colours
library(dplyr)
library(flextable)
library(officer)

# 1. Format p-value and IRR label
poisson_results_formatted <- poisson_results %>%
  mutate(
    p.value_fmt = case_when(
      p.value < 0.001 ~ "<0.001",
      TRUE ~ formatC(p.value, format = "f", digits = 3)
    ),
    IRR_label = paste0(
      round(IRR, 2), " (", 
      round(lower_CI, 2), "–", 
      round(upper_CI, 2), "), p=", 
      p.value_fmt
    ),
    # Flag significant changes
    significant = if_else(p.value < 0.05, TRUE, FALSE)
  )
# create the function
make_stroke_flextable <- function(subtype) {
  df <- poisson_results_formatted %>%
    filter(stroke_class == subtype) %>%
    select(ethnicity, comparison, IRR_label, change, significant)

  flextable(df) %>%
    bold(i = which(df$significant), bold = TRUE, part = "body") %>%
    color(i = which(df$significant), color = "black", part = "body") %>%
    autofit() %>%
    set_caption(paste("IRR Comparison –", subtype, "Stroke"))
}

# Make the tables
ft_ischaemic <- make_stroke_flextable("Ischaemic")
ft_pich <- make_stroke_flextable("PICH")
ft_sah <- make_stroke_flextable("SAH")
ft_total <- make_stroke_flextable("Total strokes")


# export them
library(officer)

# Create new Word doc
doc <- read_docx()

# Add all tables with titles
doc <- doc %>%
  body_add_par("Incidence Rate Ratios by Stroke Subtype", style = "heading 1") %>%
  body_add_par("Ischaemic", style = "heading 2") %>%
  body_add_flextable(ft_ischaemic) %>%
  body_add_par("PICH", style = "heading 2") %>%
  body_add_flextable(ft_pich) %>%
  body_add_par("SAH", style = "heading 2") %>%
  body_add_flextable(ft_sah) %>%
  body_add_par("Total Strokes", style = "heading 2") %>%
  body_add_flextable(ft_total)

# Save
print(doc, target = "IRR_stroke_tables.docx")

# and excel
library(writexl)

# Convert flextables to data.frames
df_ischaemic <- ft_ischaemic$body$dataset
df_pich <- ft_pich$body$dataset
df_sah <- ft_sah$body$dataset
df_total <- ft_total$body$dataset

# Write to Excel with named sheets
write_xlsx(
  list(
    "Ischaemic" = df_ischaemic,
    "PICH" = df_pich,
    "SAH" = df_sah,
    "Total Strokes" = df_total
  ),
  path = "IRR_stroke_tables.xlsx"
)


# ------------------------------------------------------------------
# Figure 1
# ------------------------------------------------------------------
library(ggplot2)
library(dplyr)

# Ensure period is an ordered factor for plotting
esp_asir_summary <- esp_asir_summary %>%
  mutate(period = factor(period, levels = c(
    "1995-1999", "2000-2004", "2005-2009",
    "2010-2014", "2015-2019", "2020-2024"
  )))

# Clean NA periods if any exist
esp_asir_clean <- esp_asir_summary %>%
  filter(!is.na(period)) %>%
  mutate(period = factor(period, levels = c(
    "1995-1999", "2000-2004", "2005-2009",
    "2010-2014", "2015-2019", "2020-2024"
  )))

# Improved plot function
library(ggplot2)
library(dplyr)
library(ggthemes)


plot_stroke_trend_clean <- function(stroke_type) {
  # Custom pastel palette (girly but publication-ready)
  nice_colors <- c(
  "Black African" = "#e64173",   # Pink
  "Black Caribbean" = "#7b3294", # Purple
  "White" = "#1a9850"            # Green
)
  nice_shapes <- c(
    "Black African"    = 16,  # filled circle
    "Black Caribbean"  = 17,  # triangle
    "White"            = 15   # square
  )
  esp_asir_clean %>%
    filter(
      stroke_class == stroke_type,
      !ethnicity %in% c("Overall", "Other", "Black Other"),
      !is.na(asir)
    ) %>%
    mutate(
      period = factor(
        period,
        levels = c("1995-1999", "2000-2004", "2005-2009", 
                   "2010-2014", "2015-2019", "2020-2024")
      )
    ) %>%
    ggplot(aes(x = period, y = asir, group = ethnicity, color = ethnicity, shape = ethnicity)) +
    geom_line(size = 1.5) +
    geom_point(size = 3.5) +
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), 
                  width = 0.2, size = 0.6, alpha = 0.5) +
    scale_color_manual(values = nice_colors) +
    scale_shape_manual(values = nice_shapes) +
    labs(
      title = paste("ESP-Standardised Incidence Rates:", stroke_type),
      subtitle = "95% Confidence Intervals by Ethnicity",
      x = "Time Period",
      y = "Incidence Rate per 100,000",
      color = "Ethnicity",
      shape = "Ethnicity"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "bottom",
      legend.title = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank()
    )
}


plot_stroke_trend_clean("Total strokes")
plot_stroke_trend_clean("Ischaemic")
plot_stroke_trend_clean("PICH")
plot_stroke_trend_clean("SAH")

# ------------------------------------------------------------------
# Ethnic Poisson
# ------------------------------------------------------------------

# 1. Keep only valid age groups (20+)
valid_age_groups <- c(
  "20-24", "25-29", "30-34", "35-39", "40-44", "45-49",
  "50-54", "55-59", "60-64", "65-69", "70-74", "75-79",
  "80-84", "85+"
)

poisson_ethnicity_data_ageadj <- stroke_cases_all_fixed %>%
  left_join(population_fixed, by = c("period", "ethnicity", "age_group")) %>%
  filter(
    !is.na(population),
    !is.na(n),
    age_group %in% valid_age_groups  # exclude age groups <20
  )

# 2. Poisson model function WITH age adjustment
compare_ethnicities_model_adj <- function(df) {
  print(glue::glue("Period: {unique(df$period)}, Stroke: {unique(df$stroke_class)}"))
  print(df %>% count(ethnicity, wt = n))

  # Filter out age groups with 0 cases across *all* ethnicities
  age_group_totals <- df %>%
    group_by(age_group) %>%
    summarise(total_n = sum(n, na.rm = TRUE), .groups = "drop") %>%
    filter(total_n > 0)

  df <- df %>%
    filter(age_group %in% age_group_totals$age_group)

  if (sum(df$n, na.rm = TRUE) == 0 || n_distinct(df$ethnicity) < 2) {
    message("No usable data for this group — skipping.")
    return(tibble())
  }

  df <- df %>%
    mutate(
      ethnicity = factor(ethnicity),
      ethnicity = relevel(ethnicity, ref = "White"),
      age_group = factor(age_group)
    )

  tryCatch({
    model <- glm(n ~ ethnicity + age_group,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df)

    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(grepl("^ethnicity", term)) %>%
      mutate(
        reference_group = "White",
        comparison_group = gsub("ethnicity", "", term),
        IRR = estimate,
        stroke_class = unique(df$stroke_class),
        period = unique(df$period)
      ) %>%
      select(period, stroke_class, reference_group, comparison_group,
             IRR, conf.low, conf.high, p.value)

  }, error = function(e) {
    message("Model failed: ", conditionMessage(e))
    return(tibble())
  })
}


# 3. Run the model for each period/stroke type
ethnicity_comparison_results_adj <- poisson_ethnicity_data_ageadj %>%
  group_by(period, stroke_class) %>%
  group_split() %>%
  map_dfr(compare_ethnicities_model_adj)

# 4. Add significance and formatted label
ethnicity_comparison_results_adj <- ethnicity_comparison_results_adj %>%
  mutate(
    change = case_when(
      p.value < 0.05 & IRR > 1 ~ "↑",
      p.value < 0.05 & IRR < 1 ~ "↓",
      TRUE ~ "↔"
    ),
    IRR_label = paste0(round(IRR, 2), " (", round(conf.low, 2), "–", round(conf.high, 2),
                       "), p=", ifelse(p.value < 0.001, "<0.001", formatC(p.value, format = "f", digits = 3)))
  )

library(writexl)

write_xlsx(ethnicity_comparison_results_adj, "ethnicity_comparison_results_adj.xlsx")

library(officer)
library(flextable)
library(dplyr)

# Optionally round and format for display
ethnicity_flex <- ethnicity_comparison_results_adj %>%
  mutate(
    IRR = round(IRR, 2),
    conf.low = round(conf.low, 2),
    conf.high = round(conf.high, 2),
    p.value = ifelse(p.value < 0.001, "<0.001", formatC(p.value, digits = 3, format = "f")),
    label = paste0(IRR, " (", conf.low, "–", conf.high, "), p=", p.value)
  ) %>%
  select(period, stroke_class, comparison_group, label) %>%
  arrange(period, stroke_class, comparison_group)

# Create Word document
doc <- read_docx()
doc <- body_add_par(doc, "Poisson Regression: Age-Adjusted IRRs by Ethnicity", style = "heading 1")
doc <- body_add_flextable(doc, flextable(ethnicity_flex) %>% autofit())
print(doc, target = "ethnicity_comparison_results_adj.docx")

# Too long, by strole type
library(writexl)
library(dplyr)

# Split the data by stroke_class
ethnicity_split_sheets <- ethnicity_comparison_results_adj %>%
  split(.$stroke_class)

# Export to Excel with one sheet per stroke type
write_xlsx(ethnicity_split_sheets, path = "ethnicity_comparison_by_stroke_type.xlsx")


# == Formating for the paper ==

library(ggplot2)
library(dplyr)

# Clean & format results
ethnicity_comparison_clean_adj <- ethnicity_comparison_results_adj %>%
  filter(!comparison_group %in% "Overall") %>%
  mutate(
    comparison_group = factor(
      comparison_group,
      levels = c("Black African", "Black Caribbean", "Black Other", "Other")
    ),
    period = factor(period, levels = c(
      "1995-1999", "2000-2004", "2005-2009",
      "2010-2014", "2015-2019", "2020-2024"
    )),
    sig = p.value < 0.05
  )

# Step 2: Define custom color palette
ethnicity_colors <- c(
  "Black African" = "#e64173",
  "Black Caribbean" = "#7b3294",
  "Black Other" = "#1a9850",
  "Other" = "#fdae61"
)

# Step 3: Create forest plot
plot_ethnicity_irr <- function(df, stroke_type) {
  df %>%
    filter(stroke_class == stroke_type) %>%
    distinct(period, comparison_group, IRR, conf.low, conf.high, .keep_all = TRUE) %>%
    mutate(
      comparison_group = factor(
        comparison_group,
        levels = rev(c("Black African", "Black Caribbean", "Black Other", "Other"))
      )
    ) %>%
    ggplot(aes(x = IRR, y = comparison_group, color = comparison_group)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
    facet_wrap(~ period, ncol = 3) +
    scale_color_manual(values = ethnicity_colors) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray40") +
    labs(
      title = paste("Poisson IRR Comparing Ethnicities Over Time"),
      subtitle = paste("Stroke subtype:", stroke_type, "— IRRs (vs White)"),
      x = "Incidence Rate Ratio (IRR)",
      y = "Ethnicity",
      color = "Ethnicity"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      strip.text = element_text(face = "bold", size = 12),
      legend.position = "none"
    )
}


# usage:
plot_ethnicity_irr(ethnicity_comparison_clean_adj, "Total strokes")
plot_ethnicity_irr(ethnicity_comparison_clean_adj, "Ischaemic")
plot_ethnicity_irr(ethnicity_comparison_clean_adj, "PICH")
plot_ethnicity_irr(ethnicity_comparison_clean_adj, "SAH")

# ------------------------------------------------------------------
# Adjust Poisson by SES
# ------------------------------------------------------------------
#Rebuild stroke cases with IMD Collapsing IMD into quintiles or tertiles and Suppress IRRs where counts are too low - 
## But interpretation should highlight small sample sizes and possibly collapse IMD deciles for clarity and stability

slsr_clean_imd_tertiles <- slsr_clean %>%
  mutate(
    imd_tertile = case_when(
      imd_decile %in% 1:3 ~ "High deprivation",
      imd_decile %in% 4:7 ~ "Medium deprivation",
      imd_decile %in% 8:10 ~ "Low deprivation",
      TRUE ~ "Missing"
    )
  )

# Recreate stroke_cases
stroke_cases_all_fixed_tertile <- slsr_clean_imd_tertiles %>%
  filter(!is.na(age_group), !is.na(imd_tertile)) %>%
  mutate(
    age_group = as.character(age_group),
    imd_tertile = factor(imd_tertile)
  ) %>%
  group_by(period, ethnicity, age_group, stroke_class, imd_tertile) %>%
  summarise(n = n(), .groups = "drop")

# Merge with population
poisson_ethnicity_data_tertile <- stroke_cases_all_fixed_tertile %>%
  left_join(population_fixed, by = c("period", "ethnicity", "age_group")) %>%
  filter(
    !is.na(population),
    !is.na(n),
    age_group %in% valid_age_groups
  )

# Update model
compare_ethnicities_model_age_tertile <- function(df) {
  print(glue::glue("Period: {unique(df$period)}, Stroke: {unique(df$stroke_class)}"))
  
  df <- df %>%
    filter(age_group %in% age_group[ave(n, age_group, FUN = sum) > 0]) %>%
    filter(ethnicity %in% ethnicity[ave(n, ethnicity, FUN = sum) > 0]) %>%
    mutate(
      ethnicity = factor(ethnicity),
      ethnicity = relevel(ethnicity, ref = "White"),
      age_group = factor(age_group),
      imd_tertile = factor(imd_tertile)
    )

  if (sum(df$n, na.rm = TRUE) == 0 || n_distinct(df$ethnicity) < 2) {
    return(tibble())
  }

  tryCatch({
    model <- glm(n ~ ethnicity + age_group + imd_tertile,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df)

    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(grepl("^ethnicity", term)) %>%
      mutate(
        reference_group = "White",
        comparison_group = gsub("ethnicity", "", term),
        IRR = estimate,
        stroke_class = unique(df$stroke_class),
        period = unique(df$period)
      ) %>%
      select(period, stroke_class, reference_group, comparison_group,
             IRR, conf.low, conf.high, p.value)

  }, error = function(e) {
    message("Model failed: ", conditionMessage(e))
    return(tibble())
  })
}
# Run it
ethnicity_comparison_results_age_tertile <- poisson_ethnicity_data_tertile %>%
  group_by(period, stroke_class) %>%
  group_split() %>%
  map_dfr(compare_ethnicities_model_age_tertile)


# 4. Add significance and formatted label
ethnicity_comparison_results_age_tertile <- ethnicity_comparison_results_age_tertile %>%
  mutate(
    change = case_when(
      p.value < 0.05 & IRR > 1 ~ "↑",
      p.value < 0.05 & IRR < 1 ~ "↓",
      TRUE ~ "↔"
    ),
    IRR_label = paste0(round(IRR, 2), " (", round(conf.low, 2), "–", round(conf.high, 2),
                       "), p=", ifelse(p.value < 0.001, "<0.001", formatC(p.value, format = "f", digits = 3)))
  )

# Split the data by stroke_class
ethnicity_comparison_results_age_tertile_split <- ethnicity_comparison_results_age_tertile %>%
  split(.$stroke_class)

# Export to Excel with one sheet per stroke type
write_xlsx(ethnicity_comparison_results_age_tertile_split, path = "ethnicity_imdcomparison_by_stroke_type.xlsx")

# == Adjustment table ==

library(dplyr)

# Add adjustment column
age_adj <- ethnicity_comparison_results_adj %>%
  mutate(adjustment = "Age-adjusted")

age_imd_tertile_adj <- ethnicity_comparison_results_age_tertile %>%
  mutate(adjustment = "Age + IMD-adjusted (tertiles)")

comparison_combined <- bind_rows(age_adj, age_imd_tertile_adj) %>%
  mutate(
    IRR_label = paste0(
      round(IRR, 2), " (", round(conf.low, 2), "–", round(conf.high, 2),
      "), p=", ifelse(p.value < 0.001, "<0.001", formatC(p.value, format = "f", digits = 3))
    )
  )
library(tidyr)

comparison_table_wide <- comparison_combined %>%
  select(period, stroke_class, comparison_group, adjustment, IRR_label) %>%
  pivot_wider(
    names_from = adjustment,
    values_from = IRR_label
  ) %>%
  arrange(period, stroke_class, comparison_group)

# Plotting the adjusted models

ethnicity_comparison_clean_tertile <- ethnicity_comparison_results_age_tertile %>%
  filter(!comparison_group %in% c("White", "Overall")) %>%
  mutate(
    comparison_group = factor(
      comparison_group,
      levels = rev(c("Black African", "Black Caribbean", "Black Other", "Other"))
    ),
    period = factor(period, levels = c(
      "1995-1999", "2000-2004", "2005-2009",
      "2010-2014", "2015-2019", "2020-2024"
    )),
    sig = p.value < 0.05
  )

ethnicity_colors <- c(
  "Black African" = "#e64173",
  "Black Caribbean" = "#7b3294",
  "Black Other" = "#1a9850",
  "Other" = "#fdae61"
)

# Exclude Black Other 
plot_ethnicity_irr <- function(df, stroke_type) {
  df %>%
    filter(
      stroke_class == stroke_type,
      !comparison_group %in% c("White", "Overall", "Black Other")  # ❗️ Exclude "Black Other"
    ) %>%
    distinct(period, comparison_group, IRR, conf.low, conf.high, .keep_all = TRUE) %>%
    mutate(
      comparison_group = factor(
        comparison_group,
        levels = rev(c("Black African", "Black Caribbean", "Other"))  # ❗️ Adjust order
      )
    ) %>%
    ggplot(aes(x = IRR, y = comparison_group, color = comparison_group)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
    facet_wrap(~ period, ncol = 3) +
    scale_color_manual(values = ethnicity_colors) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray40") +
    labs(
      title = "Poisson IRR Comparing Ethnicities Over Time",
      subtitle = paste("Stroke subtype:", stroke_type, "— IRRs (vs White)"),
      x = "Incidence Rate Ratio (IRR)",
      y = "Ethnicity",
      color = "Ethnicity"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      strip.text = element_text(face = "bold", size = 12),
      legend.position = "none"
    )
}


plot_ethnicity_irr(ethnicity_comparison_clean_tertile, "Ischaemic")
plot_ethnicity_irr(ethnicity_comparison_clean_tertile, "PICH")
plot_ethnicity_irr(ethnicity_comparison_clean_tertile, "SAH")

# ==There is multicolinearity between IMD and ethnicity and this inflate the results ==
# Im going to split deprivation into two: low and high 

# Recode IMD into binary
slsr_clean_imd_binary <- slsr_clean %>%
  mutate(
    imd_binary = case_when(
      imd_decile %in% 1:3 ~ "High deprivation",
      imd_decile %in% 4:10 ~ "Low/Medium deprivation",
      TRUE ~ "Missing"
    )
  )

# Inspect
table(slsr_clean_imd_binary$ethnicity, slsr_clean_imd_binary$imd_binary)

  #                High deprivation Low/Medium deprivation Missing
  Black African                865                    186       9
  Black Caribbean              927                    228      21
  Black Other                   70                     31       0
  Other                        537                    138       8
  White                       3642                   1042      77

# Stroke case with binary IMD
stroke_cases_all_fixed_binaryimd <- slsr_clean_imd_binary %>%
  filter(!is.na(age_group), imd_binary != "Missing") %>%
  group_by(period, ethnicity, age_group, stroke_class, imd_binary) %>%
  summarise(n = n(), .groups = "drop")

# Merge with population
poisson_ethnicity_data_binaryimd <- stroke_cases_all_fixed_binaryimd %>%
  left_join(population_fixed, by = c("period", "ethnicity", "age_group")) %>%
  filter(
    !is.na(population),
    !is.na(n),
    age_group %in% valid_age_groups
  )
# Poisson model
compare_ethnicities_model_age_binaryimd <- function(df) {
  print(glue::glue("Period: {unique(df$period)}, Stroke: {unique(df$stroke_class)}"))

  df <- df %>%
    filter(age_group %in% age_group[ave(n, age_group, FUN = sum) > 0]) %>%
    filter(ethnicity %in% ethnicity[ave(n, ethnicity, FUN = sum) > 0]) %>%
    mutate(
      ethnicity = factor(ethnicity),
      ethnicity = relevel(ethnicity, ref = "White"),
      age_group = factor(age_group),
      imd_binary = factor(imd_binary)
    )

  if (sum(df$n, na.rm = TRUE) == 0 || n_distinct(df$ethnicity) < 2) {
    return(tibble())
  }

  tryCatch({
    model <- glm(n ~ ethnicity + age_group + imd_binary,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df)

    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(grepl("^ethnicity", term)) %>%
      mutate(
        reference_group = "White",
        comparison_group = gsub("ethnicity", "", term),
        IRR = estimate,
        stroke_class = unique(df$stroke_class),
        period = unique(df$period)
      ) %>%
      select(period, stroke_class, reference_group, comparison_group,
             IRR, conf.low, conf.high, p.value)

  }, error = function(e) {
    message("Model failed: ", conditionMessage(e))
    return(tibble())
  })
}
# Run the model
ethnicity_comparison_results_binaryimd <- poisson_ethnicity_data_binaryimd %>%
  group_by(period, stroke_class) %>%
  group_split() %>%
  map_dfr(compare_ethnicities_model_age_binaryimd)

library(writexl)
write_xlsx(ethnicity_comparison_results_binaryimd, "ethnicity_comparison_results_binaryimd.xlsx")
# it didnt change much

# Check multicolinearity
install.packages("car")
library(car)

# Filter your data
df_vif_test <- poisson_ethnicity_data_binaryimd %>%
  filter(period == "1995-1999", stroke_class == "Ischaemic")

# Prep data
df_vif_test <- df_vif_test %>%
  filter(age_group %in% age_group[ave(n, age_group, FUN = sum) > 0]) %>%
  filter(ethnicity %in% ethnicity[ave(n, ethnicity, FUN = sum) > 0]) %>%
  mutate(
    ethnicity = factor(ethnicity),
    ethnicity = relevel(ethnicity, ref = "White"),
    age_group = factor(age_group),
    imd_binary = factor(imd_binary)
  )
# Fit the model and check vif
model_vif <- glm(n ~ ethnicity + age_group + imd_binary,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df_vif_test)

vif(model_vif)

# Testing interaction models

# 1. Filter your data
interaction_data <- poisson_ethnicity_data_tertile %>%
  filter(period == "1995-1999", stroke_class == "Ischaemic") %>%
  mutate(
    ethnicity = factor(ethnicity),
    ethnicity = relevel(ethnicity, ref = "White"),
    age_group = factor(age_group),
    imd_tertile = factor(imd_tertile)
  )

# 2. Fit interaction model
interaction_model <- glm(
  n ~ ethnicity * imd_tertile + age_group,
  offset = log(population),
  family = poisson(link = "log"),
  data = interaction_data
)

# 3. View model results
library(broom)
tidy_output <- tidy(interaction_model, exponentiate = TRUE, conf.int = TRUE)

write_xlsx(tidy_output, "poisson_interaction_model_results.xlsx")
## This got really complex and I don't really understand 

# == Let's do stratified analysis into high, medium and low 
# Create stratified dataset
tertile_stratified_models <- poisson_ethnicity_data_tertile %>%
  filter(imd_tertile %in% c("High deprivation", "Medium deprivation", "Low deprivation")) %>%
  group_by(imd_tertile, period, stroke_class) %>%
  group_split()

# Poisson function WITHOUT imd_tertile (it's now stratified)
compare_ethnicities_model_stratified <- function(df) {
  # Filter out any invalid groups
  df <- df %>%
    filter(age_group %in% age_group[ave(n, age_group, FUN = sum) > 0]) %>%
    filter(ethnicity %in% ethnicity[ave(n, ethnicity, FUN = sum) > 0]) %>%
    mutate(
      ethnicity = factor(ethnicity),
      age_group = factor(age_group)
    )

  # Skip if only one ethnicity or one age group
  if (n_distinct(df$ethnicity) < 2 || n_distinct(df$age_group) < 2) {
    message("Skipping: not enough levels for contrasts")
    return(tibble())
  }

  # Ensure White is the reference
  df <- df %>%
    mutate(ethnicity = relevel(ethnicity, ref = "White"))

  tryCatch({
    model <- glm(n ~ ethnicity + age_group,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df)

    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(grepl("^ethnicity", term)) %>%
      mutate(
        reference_group = "White",
        comparison_group = gsub("ethnicity", "", term),
        IRR = estimate,
        stroke_class = unique(df$stroke_class),
        period = unique(df$period),
        imd_tertile = unique(df$imd_tertile)
      ) %>%
      select(period, stroke_class, imd_tertile, reference_group, comparison_group,
             IRR, conf.low, conf.high, p.value)

  }, error = function(e) {
    message("Model failed: ", conditionMessage(e))
    return(tibble())
  })
}


#  Run all stratified models
ethnicity_IRR_by_tertile <- tertile_stratified_models %>%
  map_dfr(compare_ethnicities_model_stratified)

#  Save or inspect
library(writexl)
write_xlsx(ethnicity_IRR_by_tertile, "ethnicity_IRR_by_IMD_tertile.xlsx")

# Plotting these (dropping Black Other as they are too unstable)
library(ggplot2)
library(dplyr)

# Clean and prep data
ethnicity_IRR_by_tertile_clean <- ethnicity_IRR_by_tertile %>%
  filter(!comparison_group %in% c("White", "Overall")) %>%
  mutate(
    comparison_group = factor(comparison_group,
                              levels = rev(c("Black African", "Black Caribbean", "Black Other", "Other"))),
    imd_tertile = factor(imd_tertile,
                         levels = c("High deprivation", "Medium deprivation", "Low deprivation")),
    sig = p.value < 0.05
  )

# Plot function
plot_ethnicity_irr_stratified <- function(df, stroke_type) {
  df %>%
    filter(
      stroke_class == stroke_type,
      !comparison_group %in% c("White", "Overall", "Black Other")  # Drop unstable group
    ) %>%
    ggplot(aes(x = IRR, y = comparison_group, color = comparison_group)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
    facet_wrap(~ imd_tertile, scales = "free_x") +  # 🔍 Adjust scales
    scale_color_manual(values = ethnicity_colors) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray40") +
    labs(
      title = "Ethnic IRRs Stratified by IMD Tertile",
      subtitle = paste("Stroke subtype:", stroke_type, "— IRRs (vs White)"),
      x = "Incidence Rate Ratio (IRR)",
      y = "Ethnicity",
      color = "Ethnicity"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      strip.text = element_text(face = "bold", size = 12),
      legend.position = "none"
    )
}

plot_ethnicity_irr_stratified(ethnicity_IRR_by_tertile_clean, "Ischaemic")
# Overlapped, lets do faceted to see

library(ggplot2)
library(dplyr)

# Clean data for plotting
ethnicity_IRR_facet <- ethnicity_IRR_by_tertile %>%
  filter(
    !comparison_group %in% c("White", "Overall", "Black Other"),  # exclude if needed
    stroke_class == "Ischaemic"
  ) %>%
  mutate(
    comparison_group = factor(
      comparison_group,
      levels = rev(c("Black African", "Black Caribbean", "Other"))
    ),
    imd_tertile = factor(imd_tertile, levels = c("High deprivation", "Medium deprivation", "Low deprivation")),
    period = factor(period, levels = c(
      "1995-1999", "2000-2004", "2005-2009",
      "2010-2014", "2015-2019", "2020-2024"
    ))
  )

# Colors
ethnicity_colors <- c(
  "Black African" = "#e64173",
  "Black Caribbean" = "#7b3294",
  "Other" = "#fdae61"
)

# Plot with facet_grid
ggplot(ethnicity_IRR_facet, aes(x = IRR, y = comparison_group, color = comparison_group)) +
  geom_point(size = 2.5) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.25) +
  facet_grid(period ~ imd_tertile) +
  scale_color_manual(values = ethnicity_colors) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  labs(
    title = "Ethnic IRRs Stratified by IMD Tertile and Period",
    subtitle = "Stroke subtype: Ischaemic — IRRs (vs White)",
    x = "Incidence Rate Ratio (IRR)",
    y = "Ethnicity",
    color = "Ethnicity"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 13, hjust = 0.5),
    legend.position = "bottom"
  )

# Also very difficult to see. Lets plot each period separately
# Define color palette again
ethnicity_colors <- c(
  "Black African" = "#e64173",
  "Black Caribbean" = "#7b3294",
  "Other" = "#fdae61"
)

# Prepare data
ethnicity_IRR_by_tertile_clean <- ethnicity_IRR_by_tertile %>%
  filter(
    stroke_class == "Ischaemic",
    !comparison_group %in% c("White", "Overall", "Black Other")
  ) %>%
  mutate(
    comparison_group = factor(comparison_group, levels = rev(c("Black African", "Black Caribbean", "Other"))),
    imd_tertile = factor(imd_tertile, levels = c("High deprivation", "Medium deprivation", "Low deprivation")),
    period = factor(period, levels = c(
      "1995-1999", "2000-2004", "2005-2009",
      "2010-2014", "2015-2019", "2020-2024"
    ))
  )

# Plotting function
plot_irr_by_tertile_period <- function(df, selected_period) {
  df %>%
    filter(period == selected_period) %>%
    ggplot(aes(x = IRR, y = comparison_group, color = comparison_group)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
    facet_wrap(~ imd_tertile, ncol = 3) +
    scale_color_manual(values = ethnicity_colors) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
    labs(
      title = paste("Ethnic IRRs Stratified by IMD Tertile"),
      subtitle = paste("Stroke subtype: Ischaemic —", selected_period, "IRRs (vs White)"),
      x = "Incidence Rate Ratio (IRR)",
      y = "Ethnicity",
      color = "Ethnicity"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      strip.text = element_text(size = 12, face = "bold"),
      legend.position = "bottom"
    )
}

plot_irr_by_tertile_period(ethnicity_IRR_by_tertile_clean, "1995-1999")
# The problem with these is that Low deprivation has too few cases and then the CIs are too big. 
# We can collapse Medium and Low deprivation as we did before and plot those

# This has been done before
slsr_clean_imd_binary <- slsr_clean %>%
  mutate(
    imd_binary = case_when(
      imd_decile %in% 1:3 ~ "High deprivation",
      imd_decile %in% 4:10 ~ "Low/Medium deprivation",
      TRUE ~ "Missing"
    )
  )

# Poisson for binary IMD
compare_ethnicities_model_age_binaryimd <- function(df) {
  print(glue::glue("Period: {unique(df$period)}, Stroke: {unique(df$stroke_class)}, IMD: {unique(df$imd_binary)}"))

  df <- df %>%
    filter(age_group %in% age_group[ave(n, age_group, FUN = sum) > 0]) %>%
    filter(ethnicity %in% ethnicity[ave(n, ethnicity, FUN = sum) > 0]) %>%
    mutate(
      ethnicity = factor(ethnicity),
      ethnicity = relevel(ethnicity, ref = "White"),
      age_group = factor(age_group),
      imd_binary = factor(imd_binary)
    )

  # ✅ Skip if not enough ethnic groups
  if (sum(df$n, na.rm = TRUE) == 0 || n_distinct(df$ethnicity) < 2) {
    message("Skipping: Less than 2 ethnic groups present")
    return(tibble())
  }

  tryCatch({
    model <- glm(n ~ ethnicity + age_group,
                 offset = log(population),
                 family = poisson(link = "log"),
                 data = df)

    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(grepl("^ethnicity", term)) %>%
      mutate(
        reference_group = "White",
        comparison_group = gsub("ethnicity", "", term),
        IRR = estimate,
        stroke_class = unique(df$stroke_class),
        period = unique(df$period),
        imd_binary = unique(df$imd_binary)
      ) %>%
      select(period, stroke_class, imd_binary, reference_group, comparison_group,
             IRR, conf.low, conf.high, p.value)

  }, error = function(e) {
    message("Model failed: ", conditionMessage(e))
    return(tibble())
  })
}



ethnicity_comparison_results_binaryimd <- poisson_ethnicity_data_binaryimd %>%
  group_by(period, stroke_class, imd_binary) %>%
  group_split() %>%
  map_dfr(compare_ethnicities_model_age_binaryimd)

# Plot
library(ggplot2)
library(dplyr)

plot_stratified_ethnicity_irr <- function(df, stroke_type, period_input) {
  df %>%
    filter(
      stroke_class == stroke_type,
      period == period_input,
      !comparison_group %in% c("White", "Overall", "Black Other")
    ) %>%
    mutate(
      comparison_group = factor(comparison_group, levels = rev(c("Black African", "Black Caribbean", "Other"))),
      imd_binary = factor(imd_binary, levels = c("High deprivation", "Low/Medium deprivation"))
    ) %>%
    ggplot(aes(x = IRR, y = comparison_group, color = imd_binary)) +
    geom_point(size = 3, position = position_dodge(width = 0.6)) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, position = position_dodge(width = 0.6)) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "gray40") +
    labs(
      title = paste("IRR by Ethnicity (vs White) –", stroke_type),
      subtitle = paste0("Period: ", period_input),
      x = "Incidence Rate Ratio (IRR)",
      y = "Ethnicity",
      color = "IMD Level"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      legend.position = "bottom",
      plot.title.position = "plot",  # ✅ Ensures proper spacing
      plot.margin = margin(t = 15, r = 15, b = 30, l = 15)  # ✅ Extra bottom space for legend & subtitle
    ) +
    guides(color = guide_legend(override.aes = list(size = 4)))
}

plot_stratified_ethnicity_irr(ethnicity_comparison_results_binaryimd, "Ischaemic", "2015-2019")

# Save all
# Unique stroke types and periods
stroke_types <- unique(ethnicity_comparison_results_binaryimd$stroke_class)
periods <- unique(ethnicity_comparison_results_binaryimd$period)

# Loop through each combination
for (stroke in stroke_types) {
  for (period in periods) {
    
    # Build the plot
    p <- plot_stratified_ethnicity_irr(
      df = ethnicity_comparison_results_binaryimd,
      stroke_type = stroke,
      period_input = period
    )
    
    # Define filename
    filename <- paste0("IRR_ethnicity_", gsub(" ", "_", tolower(period)), "_", tolower(stroke), ".png")
    
    # Save with extra height and margin to fit legend
    ggsave(filename,
           plot = p,
           width = 8,
           height = 7,       # ✅ Extra height
           dpi = 300,
           units = "in")
    
    message("Saved: ", filename)
  }
}
library(writexl)
write_xlsx(ethnicity_comparison_results_binaryimd, "ethnicity_comparison_results_binaryimd.xlsx")

# ------------------------------------------------------------------
# Investigating causes of inequalities
# ------------------------------------------------------------------

1. Counts by ethnicity and SES

slsr_clean %>%
  filter(!is.na(ethnicity), ethnicity != "Unknown") %>%
  count(ethnicity, name = "total_cases")

2. Ethnicity and period
slsr_clean %>%
  filter(!is.na(ethnicity), ethnicity != "Unknown") %>%
  count(period, ethnicity, name = "cases") %>%
  arrange(period, ethnicity)

3. ethnicity and period and SES
slsr_clean_imd_binary %>%
  filter(!is.na(ethnicity), ethnicity != "Unknown", imd_binary != "Missing") %>%
  count(period, ethnicity, imd_binary, name = "cases") %>%
  arrange(period, ethnicity, imd_binary)

4. Export ethnicity and period and SES
ethnicity_ses_counts <- slsr_clean_imd_binary %>%
  filter(!is.na(ethnicity), ethnicity != "Unknown", imd_binary != "Missing") %>%
  count(period, ethnicity, imd_binary, name = "cases") %>%
  arrange(period, ethnicity, imd_binary)

write_xlsx(ethnicity_ses_counts, "ethnicity_ses_counts_by_period.xlsx")

5. Reorganising the table
library(tidyr)

ethnicity_ses_wide <- ethnicity_ses_counts %>%
  pivot_wider(
    names_from = period,
    values_from = cases,
    values_fill = 0
  )

write_xlsx(ethnicity_ses_wide, "ethnicity_ses_counts_wide.xlsx")

6. Differences (Chi-square) in SES distribution per period
library(dplyr)
library(tidyr)
library(purrr)

#recoding ethnicity
slsr_clean_imd_binary <- slsr_clean_imd_binary %>%
  mutate(ethnicity = case_when(
    eth6cat == 1 ~ "White",
    eth6cat == 2 ~ "Black Caribbean",
    eth6cat == 3 ~ "Black African",
    eth6cat == 4 ~ "Black Other",
    eth6cat == 5 ~ "Other",
    eth6cat == 99 ~ "Unknown",
    TRUE ~ NA_character_
  ))

# Filter relevant data
filtered_data <- slsr_clean_imd_binary %>%
  filter(!is.na(ethnicity), ethnicity != "Unknown", imd_binary != "Missing", period != "Outside range")

# Get unique periods and non-White ethnicities
periods <- unique(filtered_data$period)
ethnicities <- unique(filtered_data$ethnicity)
ethnicities <- ethnicities[ethnicities != "White"]  # Compare others vs White

# Function to run chi-square test between each ethnicity vs White per period
run_chi_per_ethnicity_period <- function(period_value, ethnicity_value) {
  df <- filtered_data %>%
    filter(period == period_value, ethnicity %in% c("White", ethnicity_value)) %>%
    count(ethnicity, imd_binary) %>%
    pivot_wider(names_from = imd_binary, values_from = n, values_fill = 0)
  
  if (nrow(df) == 2 && all(rowSums(df[,-1]) > 0)) {
    test <- chisq.test(as.matrix(df[,-1]))
    tibble(
      period = period_value,
      ethnicity_vs_white = ethnicity_value,
      p_value = test$p.value,
      statistic = test$statistic
    )
  } else {
    tibble(period = period_value, ethnicity_vs_white = ethnicity_value, p_value = NA, statistic = NA)
  }
}

# Apply across all unique combinations of period and ethnicity
results <- expand.grid(
  period = as.character(periods),
  ethnicity = as.character(ethnicities),
  stringsAsFactors = FALSE
) %>%
  pmap_dfr(~ run_chi_per_ethnicity_period(..1, ..2))


print(results, n = Inf)

# make it a nice table
library(gt)

results %>%
  mutate(
    p_value = signif(p_value, 3),
    statistic = round(statistic, 2)
  ) %>%
  arrange(period, ethnicity_vs_white) %>%
  gt() %>%
  tab_header(
    title = "Chi-squared Test: SES Differences vs White by Period",
    subtitle = "Comparing High vs Low/Medium deprivation across ethnic groups"
  ) %>%
  fmt_number(columns = c(p_value, statistic), decimals = 3) %>%
  cols_label(
    period = "Period",
    ethnicity_vs_white = "Ethnic Group (vs White)",
    p_value = "P-value",
    statistic = "Chi-squared Statistic"
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = p_value, rows = p_value < 0.05)
  )

#### Trying to make the main table

#recode variables
slsr_clean_main <- slsr_clean_imd_binary %>%
  mutate(across(
    c(rfphyp, rfpcho, rfpdep, rfpaf, sld_rec,
      kidney_rec, rfppvd, rfpihd, rfpmi, rfpdia, rfdrik),
    ~ ifelse(. == 2, 1, ifelse(. == 1, 0, NA))
  ))

slsr_clean_main <- slsr_clean_main %>%
  mutate(
    ever_smoker = case_when(
      rfsmok %in% c(2, 3) ~ 1,
      rfsmok == 1 ~ 0,
      TRUE ~ NA_real_
    )
  )

# Summary
library(dplyr)
library(tidyr)
library(broom)

# Risk factors to process
risk_factors <- c("rfphyp", "rfpcho", "rfpdep", "rfpaf", "sld_rec",
                  "kidney_rec", "rfppvd", "rfpihd", "rfpmi", "rfpdia", "rfdrik", "ever_smoker", "bmindex")

# Summary function
summarise_risk_factor <- function(data, var) {
  df <- data %>%
    group_by(ethnicity, imd_binary) %>%
    summarise(
      N = sum(!is.na(.data[[var]])),
      Mean = mean(.data[[var]], na.rm = TRUE),
      SD = if (var == "bmindex") sd(.data[[var]], na.rm = TRUE) else NA_real_,
      .groups = "drop"
    ) %>%
    mutate(
      `Risk Factor` = var,
      `Prevalence Display` = if (var == "bmindex") {
        sprintf("%.1f (%.1f)", Mean, SD)
      } else {
        sprintf("%.1f", Mean * 100)
      }
    ) %>%
    select(`Risk Factor`, ethnicity, imd_binary, N, `Prevalence Display`)
  
  return(df)
}

# adding the statistical tests (chi-squares and t-test)
get_p_value <- function(data, var, ethnicity_group, ses_group) {
  test_data <- data %>%
    filter(ethnicity %in% c("White", ethnicity_group), imd_binary == ses_group) %>%
    select(ethnicity, all_of(var)) %>%
    drop_na()

  if (length(unique(test_data$ethnicity)) < 2) return(NA)

  if (var == "bmindex") {
    t.test(value ~ ethnicity, data = rename(test_data, value = all_of(var)))$p.value
  } else {
    tbl <- table(test_data$ethnicity, test_data[[var]])
    if (all(dim(tbl) == c(2, 2))) chisq.test(tbl)$p.value else NA
  }
}

# Combine summaries
summary_table <- bind_rows(lapply(risk_factors, summarise_risk_factor, data = slsr_clean_main))
summary_table <- summary_table %>%
  rowwise() %>%
  mutate(
    `P (vs White)` = if (ethnicity != "White") {
      get_p_value(slsr_clean_main, `Risk Factor`, ethnicity, imd_binary)
    } else {
      NA_real_
    }
  ) %>%
  ungroup() %>%
  mutate(
    `P (vs White)` = case_when(
      is.na(`P (vs White)`) ~ NA_character_,
      `P (vs White)` < 0.001 ~ "<0.001",
      TRUE ~ sprintf("%.3f", `P (vs White)`)
    )
  )

write_xlsx(summary_table, "summary_table.xlsx")

white_reference <- summary_table %>%
  filter(ethnicity == "White") %>%
  select(`Risk Factor`, imd_binary, white_prevalence = Prevalence)

